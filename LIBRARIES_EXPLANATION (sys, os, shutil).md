# Подробное объяснение использования библиотек sys, os и shutil

## Оглавление
1. [Библиотека sys](#библиотека-sys)
2. [Библиотека os](#библиотека-os)
3. [Библиотека shutil](#библиотека-shutil)
4. [Сравнительная таблица](#сравнительная-таблица)

---

## Библиотека sys

### Что это?
`sys` - системная библиотека Python для работы с интерпретатором Python и системными параметрами.

### Где используется в программе?

#### 1. В файле `src/main.py`

**Строка 2: `import sys`**
- Импортирует модуль `sys` для использования в файле
- **Зачем:** Нужен для работы с аргументами командной строки и выхода из программы

**Строка 28: `original_argv = sys.argv`**
```python
original_argv = sys.argv
```
**Подробное объяснение:**
- `sys.argv` - это **список** (list), который содержит аргументы командной строки
- **Что внутри?**
  - `sys.argv[0]` - имя запущенного скрипта (например, "minishell" или путь к файлу)
  - `sys.argv[1]` - первый аргумент
  - `sys.argv[2]` - второй аргумент
  - И так далее...
- **Пример:** Если запустить `python src/main.py ls -l`, то:
  ```python
  sys.argv = ["src/main.py", "ls", "-l"]
  ```
- **Зачем сохранять?** Чтобы потом восстановить оригинальное значение
- `original_argv` - переменная, которая "запоминает" исходные аргументы

**Строка 32: `sys.argv = ["minishell"] + user_input.strip().split()`**
```python
sys.argv = ["minishell"] + user_input.strip().split()
```
**Подробное объяснение по частям:**

1. `user_input.strip()` - убирает пробелы в начале и конце строки
   - Пример: `"  ls -l  "` → `"ls -l"`

2. `.split()` - разбивает строку на список слов по пробелам
   - Пример: `"ls -l"` → `["ls", "-l"]`
   - Пример: `"cp file.txt copy.txt"` → `["cp", "file.txt", "copy.txt"]`

3. `["minishell"] + ...` - создает список с одним элементом "minishell" и добавляет к нему список из команды
   - `["minishell"] + ["ls", "-l"]` → `["minishell", "ls", "-l"]`

4. `sys.argv = ...` - **заменяет** аргументы командной строки на новые

**Полный пример:**
```python
# Пользователь ввел: "ls -l"
# Исходно: sys.argv = ["src/main.py"]

user_input = "ls -l"
user_input.strip()                    # "ls -l" (убрали пробелы)
user_input.strip().split()            # ["ls", "-l"] (разбили на слова)
["minishell"] + ["ls", "-l"]          # ["minishell", "ls", "-l"]
sys.argv = ["minishell", "ls", "-l"]  # Подменили аргументы
```

**Зачем это нужно?**
- Typer читает `sys.argv`, чтобы понять, какую команду выполнить
- Мы временно "подделываем" аргументы, чтобы Typer думал, что была вызвана команда `ls -l`
- Это позволяет использовать Typer внутри нашей программы

**Строка 45: `sys.argv = original_argv`**
```python
sys.argv = original_argv
```
**Подробное объяснение:**
- Восстанавливаем оригинальное значение `sys.argv`
- **Зачем?** Чтобы не сломать работу программы, если после выполнения команды что-то еще использует `sys.argv`
- Это делается в блоке `finally`, поэтому выполнится **всегда**, даже если была ошибка

**Строка 87: `if len(sys.argv) > 1:`**
```python
if len(sys.argv) > 1:
```
**Подробное объяснение:**
- `len(sys.argv)` - длина списка аргументов (количество элементов)
- `sys.argv[0]` - всегда имя скрипта (минимум 1 элемент)
- `> 1` означает "есть аргументы кроме имени скрипта"
- **Примеры:**
  ```python
  # Запуск: python src/main.py
  sys.argv = ["src/main.py"]
  len(sys.argv) = 1  # Только имя скрипта
  # Условие False → интерактивный режим
  
  # Запуск: python src/main.py ls
  sys.argv = ["src/main.py", "ls"]
  len(sys.argv) = 2  # Есть аргумент!
  # Условие True → выполнить команду
  ```

**Строка 89: `command = ' '.join(sys.argv[1:])`**
```python
command = ' '.join(sys.argv[1:])
```
**Подробное объяснение:**
- `sys.argv[1:]` - срез списка (все элементы начиная с индекса 1)
  - Если `sys.argv = ["src/main.py", "ls", "-l"]`
  - То `sys.argv[1:] = ["ls", "-l"]` (убрали имя скрипта)
- `' '.join(...)` - соединяет элементы списка пробелами
  - `' '.join(["ls", "-l"])` → `"ls -l"`
  - `' '.join(["cp", "file.txt", "copy.txt"])` → `"cp file.txt copy.txt"`
- **Результат:** Получаем команду как одну строку

**Полный пример:**
```python
# Запуск: python src/main.py cp file.txt copy.txt
sys.argv = ["src/main.py", "cp", "file.txt", "copy.txt"]
sys.argv[1:] = ["cp", "file.txt", "copy.txt"]
' '.join(["cp", "file.txt", "copy.txt"]) = "cp file.txt copy.txt"
command = "cp file.txt copy.txt"
```

#### 2. В файле `src/fuuuuuuuuuck.py`

**Строка 5: `import sys`**
- Импортирует `sys` для использования

**Строка 431: `sys.exit(0)`**
```python
sys.exit(0)
```
**Подробное объяснение:**
- `sys.exit()` - **немедленно** завершает выполнение программы
- Аргумент `0` - код возврата (exit code)
  - `0` = успешное завершение (всё хорошо)
  - Любое другое число = ошибка
  - Операционная система может проверить этот код
- **Зачем?** Команда `exit` должна завершить программу, а не просто вернуться

**Аналогия:** Как нажать кнопку выключения компьютера - программа останавливается сразу

#### 3. В файле `src/config.py`

**Строка 2: `import sys`**
- Импортирует `sys` для вывода ошибок

**Строка 53: `print(..., file=sys.stderr)`**
```python
print(f"Ошибка: не удалось создать директорию {history_file.parent}: {e}", file=sys.stderr)
```
**Подробное объяснение:**
- По умолчанию `print()` пишет в `stdout` (стандартный вывод) - обычно это экран
- `sys.stderr` - поток для ошибок (standard error)
- **Зачем разделять?**
  - `stdout` - для обычного вывода
  - `stderr` - для ошибок и предупреждений
  - Можно перенаправить отдельно: `program 2> errors.txt` (только ошибки)
- **Почему важно:** Ошибки должны быть отдельно от обычного вывода

**Строка 95: Аналогично - вывод ошибки сохранения истории в stderr**

---

## Библиотека os

### Что это?
`os` - библиотека для работы с операционной системой: файлы, папки, переменные окружения, пути.

### Где используется в программе?

#### 1. В файле `src/fuuuuuuuuuck.py`

**Строка 4: `import os`**
- Импортирует модуль `os`

**Строка 16: `self.current_dir = os.getcwd()`**
```python
self.current_dir = os.getcwd()
```
**Подробное объяснение:**
- `os.getcwd()` - **Get Current Working Directory**
- Возвращает **полный путь** к текущей рабочей директории
- **Примеры:**
  - Linux/Mac: `"/home/user/project"`
  - Windows: `"C:\Users\User\project"`
- **Зачем сохранять?** Чтобы знать, откуда запущена программа, даже если потом перейдем в другую папку
- Сохраняем в `self.current_dir` для использования в командах

**Строка 68: `os.getenv('USER') or os.getenv('USERNAME')`**
```python
username = os.getenv('USER') or os.getenv('USERNAME') or 'unknown'
```
**Подробное объяснение:**
- `os.getenv('USER')` - получает значение переменной окружения `USER`
  - В Linux/Mac: обычно имя пользователя
  - В Windows: обычно `None` (не существует)
- `os.getenv('USERNAME')` - получает переменную `USERNAME`
  - В Windows: обычно имя пользователя
  - В Linux/Mac: может быть `None`
- `or` - логический оператор "ИЛИ"
  - Если первое значение `None` или пустое, берется второе
  - `None or "John"` → `"John"`
  - `"Alice" or "John"` → `"Alice"` (первое непустое)
- **Цепочка:** Пробуем `USER`, если нет - `USERNAME`, если нет - `'unknown'`
- **Зачем:** Узнать имя пользователя для логирования

**Строка 71: `os.getcwd()` в логировании**
```python
context = f"[CWD: {os.getcwd()}] [USER: {username}]"
```
**Подробное объяснение:**
- `os.getcwd()` - текущая рабочая директория на момент выполнения команды
- Может отличаться от `shell_state.current_dir`, если пользователь перешел в другую папку через `cd`
- Используется для записи в лог, где была выполнена команда

**Строка 82: `os.path.expanduser('~')`**
```python
if path == '~':
    return os.path.expanduser('~')
```
**Подробное объяснение:**
- `os.path.expanduser('~')` - преобразует символ `~` в полный путь к домашней директории
- **Примеры:**
  - Linux/Mac: `"~"` → `"/home/username"`
  - Windows: `"~"` → `"C:\Users\Username"`
- **Зачем:** Пользователь может ввести `cd ~` или `ls ~/Documents`, нужно преобразовать

**Строка 84: `os.path.join(os.path.expanduser('~'), path[2:])`**
```python
elif path.startswith('~/'):
    return os.path.join(os.path.expanduser('~'), path[2:])
```
**Подробное объяснение:**
- `path[2:]` - берем строку начиная с 3-го символа (индекс 2)
  - `"~/Documents"` → `path[2:]` = `"Documents"` (убрали `"~/"`)
- `os.path.expanduser('~')` - получаем домашнюю папку
- `os.path.join(..., ...)` - правильно соединяет пути
  - `os.path.join("/home/user", "Documents")` → `"/home/user/Documents"`
  - `os.path.join("C:\\Users\\User", "Documents")` → `"C:\\Users\\User\\Documents"`
- **Почему `os.path.join()` а не просто `+`?**
  - Правильно работает на разных ОС (Windows и Linux используют разные разделители)
  - Автоматически добавляет правильный разделитель (`/` или `\`)

**Строка 86: `os.path.abspath(os.path.join(...))`**
```python
return os.path.abspath(os.path.join(shell_state.current_dir, path))
```
**Подробное объяснение:**
- `os.path.join(shell_state.current_dir, path)` - соединяет текущую директорию с путем
  - Если `current_dir = "/home/user"` и `path = "Documents"`
  - Результат: `"/home/user/Documents"`
- `os.path.abspath(...)` - преобразует в **абсолютный путь** (полный путь от корня)
  - Если `path = "./test"` и мы в `/home/user/project`
  - `os.path.join("/home/user/project", "./test")` = `"/home/user/project/./test"`
  - `os.path.abspath(...)` = `"/home/user/project/test"` (упростил путь)
- **Зачем:** Всегда работать с полными путями, чтобы избежать проблем

**Строка 97: `os.path.exists(resolved_path)`**
```python
if not os.path.exists(resolved_path):
```
**Подробное объяснение:**
- `os.path.exists(путь)` - проверяет, существует ли файл или папка
- Возвращает `True` если существует, `False` если нет
- **Примеры:**
  - `os.path.exists("/home/user/file.txt")` → `True` (если файл есть)
  - `os.path.exists("/nonexistent")` → `False`
- **Зачем:** Перед работой с файлом нужно убедиться, что он существует

**Строка 101: `os.path.isdir(resolved_path)`**
```python
if not os.path.isdir(resolved_path):
```
**Подробное объяснение:**
- `os.path.isdir(путь)` - проверяет, является ли путь **директорией** (папкой)
- Возвращает `True` для папок, `False` для файлов или несуществующих путей
- **Разница с `exists()`:**
  - `exists()` - "существует ли?" (файл или папка)
  - `isdir()` - "это папка?" (только папка)
- **Зачем:** Команда `ls` работает только с папками, не с файлами

**Строка 104: `os.listdir(resolved_path)`**
```python
items = os.listdir(resolved_path)
```
**Подробное объяснение:**
- `os.listdir(путь)` - возвращает **список имен** всех файлов и папок в указанной директории
- **Пример:**
  ```python
  # В папке /home/user есть: file.txt, folder/, another.txt
  os.listdir("/home/user")
  # Результат: ["file.txt", "folder", "another.txt"]
  ```
- Возвращает только **имена**, не полные пути
- **Зачем:** Чтобы показать пользователю содержимое папки

**Строка 109: `os.path.join(resolved_path, item)`**
```python
full_path = os.path.join(resolved_path, item)
```
**Подробное объяснение:**
- Соединяет путь к папке с именем файла/папки
- **Пример:**
  - `resolved_path = "/home/user/Documents"`
  - `item = "file.txt"`
  - Результат: `"/home/user/Documents/file.txt"`
- **Зачем:** Нужен полный путь, чтобы получить информацию о файле (размер, дата)

**Строка 110: `os.stat(full_path)`**
```python
stat = os.stat(full_path)
```
**Подробное объяснение:**
- `os.stat(путь)` - получает **статистику** (информацию) о файле или папке
- Возвращает объект со свойствами:
  - `stat.st_size` - размер в байтах
  - `stat.st_mtime` - время последней модификации (timestamp)
  - `stat.st_mode` - права доступа
- **Пример использования:**
  ```python
  stat = os.stat("/home/user/file.txt")
  print(stat.st_size)      # 1024 (размер)
  print(stat.st_mtime)     # 1698765432.5 (время)
  ```
- **Зачем:** Для команды `ls -l` нужна подробная информация

**Строка 129-132: Аналогично для команды `cd`**
- Проверки `os.path.exists()` и `os.path.isdir()` те же самые
- Проверяем, что папка существует и это действительно папка

**Строка 134: `os.chdir(resolved_path)`**
```python
os.chdir(resolved_path)
```
**Подробное объяснение:**
- `os.chdir()` - **Change Directory** - меняет текущую рабочую директорию процесса
- Это системный вызов - меняет директорию для всей программы Python
- **Пример:**
  ```python
  os.getcwd()  # "/home/user"
  os.chdir("/home/user/Documents")
  os.getcwd()  # "/home/user/Documents"
  ```
- **Важно:** Это изменяет директорию **для всей программы**, не только для оболочки
- После `chdir()` все относительные пути будут от новой директории

**Строка 135: `shell_state.current_dir = os.getcwd()`**
```python
shell_state.current_dir = os.getcwd()
```
**Подробное объяснение:**
- Обновляем сохраненное значение текущей директории
- Теперь `shell_state.current_dir` совпадает с реальной директорией процесса
- **Зачем:** Чтобы другие команды знали, где мы находимся

**Строка 151: `os.path.isdir(resolved_file)` в команде `cat`**
```python
if os.path.isdir(resolved_file):
    raise IsADirectoryError(...)
```
**Подробное объяснение:**
- Проверка: если путь - это папка, а не файл
- **Зачем:** Команда `cat` читает файлы, а не папки
- Выбрасываем ошибку, чтобы пользователь понял проблему

**Строка 179: `os.path.isdir(resolved_source)` в команде `cp`**
```python
if os.path.isdir(resolved_source) and not recursive:
```
**Подробное объяснение:**
- Проверяем, является ли источник папкой
- Если да И нет флага `-r` (recursive) → ошибка
- **Зачем:** Копирование папок требует флага `-r` для безопасности

**Строка 182: `if os.path.isdir(resolved_source):`**
```python
if os.path.isdir(resolved_source):
    shutil.copytree(...)  # Копируем папку
else:
    shutil.copy2(...)     # Копируем файл
```
**Подробное объяснение:**
- Разветвление логики: папка или файл?
- Для папок нужна другая функция копирования (рекурсивная)
- Для файлов - простая функция

**Строка 228: `os.path.expanduser('~')` в защите от удаления**
```python
protected_paths = ['/', os.path.expanduser('~')]
```
**Подробное объяснение:**
- Создаем список защищенных путей
- `'/'` - корневая директория системы (Linux/Mac)
- `os.path.expanduser('~')` - домашняя папка пользователя
- **Зачем:** Защита от случайного удаления важных папок

**Строка 229: `os.path.dirname(resolved_target)`**
```python
if resolved_target in protected_paths or os.path.dirname(resolved_target) in protected_paths:
```
**Подробное объяснение:**
- `os.path.dirname(путь)` - получает директорию, содержащую файл
- **Примеры:**
  - `os.path.dirname("/home/user/file.txt")` → `"/home/user"`
  - `os.path.dirname("/home/user/folder/sub")` → `"/home/user/folder"`
- **Зачем:** Защищаем не только корневые папки, но и всё внутри них
  - Если `resolved_target = "/home/user/important/file.txt"`
  - То `dirname()` = `"/home/user/important"` или `/home/user`
  - Проверяем, не в защищенной ли папке

**Строка 235: `os.path.isdir(resolved_target)` в команде `rm`**
- Проверка: файл или папка для удаления?
- Для папок нужна рекурсивная функция удаления

**Строка 253: `os.remove(resolved_target)`**
```python
os.remove(resolved_target)
```
**Подробное объяснение:**
- `os.remove(путь)` - удаляет **один файл**
- **Не работает с папками!** Только файлы
- **Пример:**
  ```python
  os.remove("/home/user/file.txt")  # Удалит файл
  ```
- **Ошибка:** Если файл не существует → `FileNotFoundError`
- **Зачем:** Для удаления одиночных файлов

**Строка 320: `os.path.isfile(resolved_path)` в команде `grep`**
```python
if os.path.isfile(resolved_path):
```
**Подробное объяснение:**
- `os.path.isfile(путь)` - проверяет, является ли путь **файлом** (не папкой)
- Обратное от `isdir()`
- **Зачем:** В команде `grep` разная логика для файлов и папок

**Строка 322: `os.path.isdir(resolved_path)`**
- Проверка для папок в `grep`

**Строка 323: `os.walk(resolved_path)`**
```python
for root, dirs, files in os.walk(resolved_path):
```
**Подробное объяснение:**
- `os.walk(путь)` - рекурсивно обходит все папки и файлы внутри
- Возвращает итератор, который дает кортежи `(root, dirs, files)`:
  - `root` - текущая папка
  - `dirs` - список подпапок в текущей папке
  - `files` - список файлов в текущей папке
- **Пример:**
  ```
  Структура:
  /home/user/
    ├── file1.txt
    └── folder/
        └── file2.txt
  ```
  Итерации:
  ```python
  # Первая итерация
  root = "/home/user"
  dirs = ["folder"]
  files = ["file1.txt"]
  
  # Вторая итерация
  root = "/home/user/folder"
  dirs = []
  files = ["file2.txt"]
  ```
- **Зачем:** Для рекурсивного поиска в папках (`grep -r`)

**Строка 325: `os.path.join(root, file)`**
- Соединяет путь к текущей папке с именем файла
- Получаем полный путь к каждому файлу при обходе

**Строка 355: `os.path.isfile(resolved_source)` в команде `zip`**
- Проверка: файл или папка для архивации
- Разная логика для каждого случая

**Строка 356: `os.path.basename(resolved_source)`**
```python
zipf.write(resolved_source, os.path.basename(resolved_source))
```
**Подробное объяснение:**
- `os.path.basename(путь)` - извлекает только **имя файла** из полного пути
- **Примеры:**
  - `os.path.basename("/home/user/file.txt")` → `"file.txt"`
  - `os.path.basename("C:\\Users\\User\\file.txt")` → `"file.txt"`
  - `os.path.basename("/home/user/folder/")` → `"folder"`
- **Зачем в zip:** В архиве храним только имя файла, без полного пути
  - Иначе архив будет содержать `/home/user/file.txt` вместо `file.txt`

**Строка 358: `os.walk(resolved_source)`**
- Рекурсивный обход папки для архивации всех файлов внутри

**Строка 360: `os.path.join(root, file)`**
- Создание полного пути к каждому файлу

**Строка 361: `os.path.relpath(file_path, resolved_source)`**
```python
arcname = os.path.relpath(file_path, resolved_source)
```
**Подробное объяснение:**
- `os.path.relpath(путь, начало)` - получает **относительный путь** от начальной точки
- **Пример:**
  ```python
  resolved_source = "/home/user/project"
  file_path = "/home/user/project/src/main.py"
  os.path.relpath(file_path, resolved_source)
  # Результат: "src/main.py"
  ```
- **Зачем:** В архиве сохраняем структуру папок относительно корня архива
- Вместо `/home/user/project/src/main.py` будет `src/main.py`

#### 2. В файле `src/main.py`

**Строка 3: `import os`**
- Импорт модуля `os`

**Строка 56: `os.path.basename(shell_state.current_dir)`**
```python
prompt = f"{os.path.basename(shell_state.current_dir)} $ "
```
**Подробное объяснение:**
- `shell_state.current_dir` - полный путь к текущей папке (например, `"/home/user/project"`)
- `os.path.basename(...)` - извлекает только имя папки (`"project"`)
- **Результат:** Приглашение показывает только имя папки: `"project $ "` вместо `"/home/user/project $ "`
- **Зачем:** Более короткое и читаемое приглашение

#### 3. В файле `src/config.py`

**Строка 1: `import os`**
- Импорт модуля `os`

**Строка 76: `os.fsync(f.fileno())`**
```python
os.fsync(f.fileno())
```
**Подробное объяснение:**
- `f.fileno()` - получает **файловый дескриптор** (номер файла в операционной системе)
  - Это низкоуровневый идентификатор открытого файла
- `os.fsync(дескриптор)` - **принудительно** записывает все данные из буфера на диск
- **Что такое буфер?**
  - Операционная система хранит данные в памяти (буфере) перед записью
  - Это быстрее, но данные могут быть потеряны при сбое
- **Зачем `fsync()`:** Гарантировать, что данные **точно** записаны на диск
- **Аналогия:** Как "сохранить" в текстовом редакторе - данные больше не потеряются при сбое

**Важно:** `fsync()` может быть медленным, но гарантирует сохранность данных

---

## Библиотека shutil

### Что это?
`shutil` - библиотека для операций высокого уровня с файлами и папками (копирование, перемещение, удаление).

### Где используется в программе?

**Строка 8: `import shutil`**
- Импорт модуля `shutil`

#### Команда `cp` - копирование

**Строка 183: `shutil.copytree(resolved_source, resolved_dest)`**
```python
if os.path.isdir(resolved_source):
    shutil.copytree(resolved_source, resolved_dest)
```
**Подробное объяснение:**
- `shutil.copytree(источник, назначение)` - **рекурсивно** копирует всю папку со всем содержимым
- **Что делает:**
  - Создает папку назначения
  - Копирует все файлы из источника
  - Рекурсивно копирует все подпапки и файлы в них
- **Пример:**
  ```python
  # Исходная структура:
  folder/
    ├── file1.txt
    └── subfolder/
        └── file2.txt
  
  shutil.copytree("folder", "folder_copy")
  
  # Результат:
  folder_copy/
    ├── file1.txt
    └── subfolder/
        └── file2.txt
  ```
- **Важно:** Папка назначения **не должна существовать** заранее, иначе будет ошибка
- **Зачем:** Для копирования папок нужно копировать всё содержимое

**Строка 185: `shutil.copy2(resolved_source, resolved_dest)`**
```python
else:
    shutil.copy2(resolved_source, resolved_dest)
```
**Подробное объяснение:**
- `shutil.copy2(источник, назначение)` - копирует **один файл**
- **Отличие от `copy()`:** Сохраняет метаданные (дату модификации, права доступа)
- **Что делает:**
  - Копирует содержимое файла
  - Сохраняет дату последнего изменения
  - Сохраняет права доступа (если возможно)
- **Пример:**
  ```python
  shutil.copy2("file.txt", "copy.txt")
  # Создает копию с теми же датой и правами
  ```
- **Зачем `copy2` вместо `copy`:** Чтобы сохранить оригинальную дату создания файла

#### Команда `mv` - перемещение

**Строка 208: `shutil.move(resolved_source, resolved_dest)`**
```python
shutil.move(resolved_source, resolved_dest)
```
**Подробное объяснение:**
- `shutil.move(источник, назначение)` - **перемещает** файл или папку
- **Что делает:**
  - Если назначение в той же файловой системе → просто переименовывает (быстро)
  - Если назначение в другой файловой системе → копирует и удаляет исходный (медленнее)
- **Работает для:**
  - Файлов
  - Папок (вместе со всем содержимым)
- **Примеры:**
  ```python
  # Переименование файла:
  shutil.move("old.txt", "new.txt")
  # "old.txt" больше не существует, есть "new.txt"
  
  # Перемещение в другую папку:
  shutil.move("file.txt", "folder/file.txt")
  # Файл теперь в папке folder/
  
  # Перемещение папки:
  shutil.move("old_folder", "new_folder")
  # Вся папка переименована
  ```
- **Зачем:** Универсальная функция для перемещения и переименования

#### Команда `rm` - удаление

**Строка 245: `shutil.rmtree(resolved_target)`**
```python
shutil.rmtree(resolved_target)
```
**Подробное объяснение:**
- `shutil.rmtree(путь)` - **рекурсивно удаляет** папку со всем содержимым
- **Что делает:**
  - Удаляет все файлы внутри
  - Удаляет все подпапки (рекурсивно)
  - Удаляет саму папку
- **Опасность:** Удаляет **безвозвратно** (в корзину не попадает!)
- **Пример:**
  ```python
  # Структура:
  folder/
    ├── file1.txt
    └── subfolder/
        └── file2.txt
  
  shutil.rmtree("folder")
  # Всё удалено: и folder, и file1.txt, и subfolder/file2.txt
  ```
- **Зачем:** Для удаления папок нужна рекурсивная функция
- **Важно:** Это необратимая операция!

---

## Сравнительная таблица

| Библиотека | За что отвечает | Основные функции в проекте |
|------------|----------------|----------------------------|
| **sys** | Работа с интерпретатором Python | `sys.argv` - аргументы командной строки<br>`sys.exit()` - выход из программы<br>`sys.stderr` - поток ошибок |
| **os** | Работа с операционной системой | `os.getcwd()` - текущая папка<br>`os.chdir()` - сменить папку<br>`os.path.*` - работа с путями<br>`os.listdir()` - список файлов<br>`os.walk()` - рекурсивный обход<br>`os.remove()` - удалить файл<br>`os.getenv()` - переменные окружения |
| **shutil** | Высокоуровневые операции с файлами | `shutil.copy2()` - копировать файл<br>`shutil.copytree()` - копировать папку<br>`shutil.move()` - переместить<br>`shutil.rmtree()` - удалить папку |

---

## Итоговая схема работы

### Процесс выполнения команды `cp file.txt copy.txt`:

```
1. Пользователь вводит: "cp file.txt copy.txt"
   ↓
2. sys.argv подменяется: ["minishell", "cp", "file.txt", "copy.txt"]
   ↓
3. Typer вызывает функцию cp()
   ↓
4. resolve_path() использует os.path.join() и os.path.abspath()
   ↓
5. os.path.exists() проверяет существование file.txt
   ↓
6. os.path.isdir() проверяет, что это файл, а не папка
   ↓
7. shutil.copy2() копирует файл
   ↓
8. os.getcwd() получает текущую папку для лога
   ↓
9. log_command() записывает действие в shell.log
   ↓
10. sys.argv восстанавливается в оригинальное значение
```

---

## Практические советы

### Когда использовать `os.path.join()`?
- **Всегда** при соединении путей
- Правильно работает на Windows и Linux
- Пример: `os.path.join("folder", "file.txt")` вместо `"folder/file.txt"`

### Когда использовать `os.path.abspath()`?
- Когда нужен полный путь от корня системы
- Когда работаете с относительными путями (`.`, `..`)
- Пример: `os.path.abspath("./file.txt")` → полный путь

### Когда использовать `shutil` вместо `os`?
- **shutil** - для операций высокого уровня (копировать всё сразу)
- **os** - для операций низкого уровня (создать файл, удалить один файл)
- Примеры:
  - Копировать папку → `shutil.copytree()` (не делать вручную)
  - Копировать файл → `shutil.copy2()` (проще чем открывать и читать)

---

## Заключение

**sys** - для управления программой (аргументы, выход, потоки)  
**os** - для работы с файловой системой (папки, файлы, пути)  
**shutil** - для удобных операций (копирование, перемещение папок)

Все три библиотеки работают вместе, чтобы обеспечить полноценную работу с файлами и папками в мини-оболочке.


